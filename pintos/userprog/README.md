# 프로젝트 2: 사용자 프로그램

- 사용자 프로그램 실행을 가능하게 하는 시스템 구축해야함
- 기본 코드 지원사항:  프로그램 로드 및 실행
- 미지원 사항: I/O 또는 OS와의 상호작용
- 추가 과제: 선택사항

## 배경

- 테스트 코드를 포함한 지금까지의 모든 코드: 운영체제 커널의 일부였음 = 모든 부분에 접근 권한을 가짐
- 지금부터는 사용자 프로그램을 실행하기 때문에 접근 권한 관련 처리를 해야함.

- 2개 이상의 프로세스가 동시에 실행 될 수 있도록 허용
- 스레드는 각 프로세스별 1개로 제한

- 지금까지는 커널 내에서 특정 함수 인터페이스를 사용해야했으나, 이제는 아님

- 동기화와 가상주소 읽기

## 소스코드

- `process.c`, `process.h`: ELF 바이너리를 로드하고 프로세스를 시작.
- `syscall.c`, `syscall.h`:
    - 사용자 프로세스가 커널 기능을 사용하려고 할 때 시스템 호출을 호출함. 시스템 호출 핸들러의 골격
    - 현재: 메시지를 출력하고 사용자 프로세스를 종료하는 기능만 있음
    - 할것: 추가 기능 구현
- `exception.c`, `exception.h`
    - 사용자 프로세스가 금지된 작업을 수행할 때, exception 또는 fault로 커널에 트랩되는데
    - 이 파일에서 예외를 처리함.
    - 현재: 단순히 메시지 출력 후 프로세스 종료
    - 할것: `page_fault()`를 수정해야함.
- `gdt.c`, `gdt.h`
    - x86-64는 [세그먼트 아키텍처](#세그먼트-아키텍처)
- `syscall-entry.S`: 시스템 호출 핸들러를 부트스트랩하는 작은 어셈블리 코드. 이 코드를 이해할 필요는 없음

## 파일 시스템 사용하기

- filesys 디렉토리에 파일시스템이 구현되어있음
- `filesys.h` 및 `file.h` 참고하되 수정할 필요는 없음
- 제한 사항
    - 내부 동기화 없음: 한 번에 하나의 프로세스만 파일 시스템 코드를 실행하도록 구현해야함
    - 파일 크기는 생성 시 고정: 루트 디렉토리가 파일로 표현되므로 생성할 수 있는 파일 수도 제한.
    - 파일 데이터는 단일 익스텐트(extent)로 할당: 단일 파일의 데이터는 디스크의 연속적인 섹터 범위를 차지해야 함. -> 외부 단편화가 심해질 수 있음
    - 하위 디렉토리 없음
    - 파일 이름은 14자로 제한
    - 작업 중 시스템 충돌 시 손상될 수 있으며 파일 시스템 복구 도구는 없음.
- 주요 특징
    - `filesys_remove()`
        - UNIX와 유사 파일이 열려 있는 동안 제거되면, 해당 블록은 할당 해제되지 않으며 마지막으로 닫는 스레드까지 해당 파일을 열어둔 모든 스레드에서 계속 접근할 수 있음
        - 참고: [열린 파일 제거](#열린-파일-제거)

### 프로그램을 Pintos 가상 머신에 넣기

- 파일 시스템 파티션이 있는 디스크를 생성하고, 파일 시스템을 포맷하고, 이 프로젝트의 두 번째 테스트 케이스인 args-single 프로그램을 새 디스크에 복사한 다음, 'onearg' 인수를 전달하여 실행하는
  방법의 요약
- `userprog/build` 에서
- `pintos-mkdisk filesys.dsk 10`
- `pintos --fs-disk filesys.dsk -p tests/userprog/args-single:args-single -- -q -f run 'args-single onearg'`

## 사용자 프로그램 작동 방식

- Pintos는 일반 C 프로그램을 실행할 수 있으나, 메모리에 맞고 여러분이 구현할 시스템 호출만 사용하는 경우에 해당
- 시스템 호출 중 메모리 할당을 허용하는 것이 없으므로 malloc()은 구현할 수 없음
- 부동 소수점 연산을 사용하는 프로그램은 실행할 수 없음
- `userprog/process.c`에 제공된 로더로 ELF 실행 파일을 로드할 수 있음

## 가상 메모리 레이아웃

- 가상 메모리는 사용자 가상 메모리와 커널 가상 메모리의 두 영역으로 나뉨
    - 사용자 가상 메모리
        - 가상 주소: 0 ~ `KERN_BASE`
            - `KERN_BASE`: `include/threads/vaddr.h`에 정의 / 기본값은 `0x8004000000`
        - 사용자 가상 메모리는 프로세스 별로 할당됨.
        - 따라서 프로세스 별로 페이지 테이블을 가지고 있고, 그걸 모아둔 것이 페이지 디렉토리
        - 각각의 페이지 디렉토리 엔트리에는 페이지 테이블의 첫주소를 가지고 있음.
        - 프로세스를 전환할 때는 CR3 레지스터라는 특별한 레지스터에 해당하는 프로세스의 페이지 디렉터리 주소를 넣어줘야함.
        - `struct thread`는 프로세스의 페이지 테이블에 대한 포인터를 포함
    - 커널 가상 메모리
        - 가상 주소: `KERN_BASE` ~
            - 물리 메모리와 1:1 매핑
                - `KERN_BASE`: 물리주소 0
                - `KERN_BASE + 0x1234`: 물리주소 0x1234
            - 시스템의 물리 메모리 크기까지 계속됨.
        - 전역적임. 어떤 사용자 프로세스나 커널 스레드가 실행중인지에 관계없이 항상 동일한 방식으로 매핑됨.
    - 사용자 프로그램은 자신의 사용자 가상 메모리만 접근 할 수 있어야함.
        - 커널 가상 메모리에 접근하려고 시도하면 페이지 폴트 발생 후 프로세스 종료 -> `userprog/exception.c`의 `page_fault()`에 의해 처리
    - 커널 스레드
        - 커널 가상 메모리 접근 가능
        - 사용자 프로세스가 실행 중인 프로세스의 사용자 가상 메모리 접근 가능
        - 물리 메모리와 매핑되지 않은 사용자 가상 주소의 메모리에 접근하려고 시도하면 페이지 폴트가 발생

## 전형적인 메모리 레이아웃

- 사용자 가상메모리 레이아웃

```
USER_STACK +----------------------------------+
           |             user stack           |
           |                 |                |
           |                 |                |
           |                 V                |
           |           grows downward         |
           |                                  |
           |                                  |
           |                                  |
           |                                  |
           |           grows upward           |
           |                 ^                |
           |                 |                |
           |                 |                |
           +----------------------------------+
           | uninitialized data segment (BSS) |
           +----------------------------------+
           |     initialized data segment     |
           +----------------------------------+
           |            code segment          |
 0x400000  +----------------------------------+
           |                                  |
           |                                  |
           |                                  |
           |                                  |
           |                                  |
       0   +----------------------------------+
```

- project2까지는 스택 크기 고정
- **링커**: 링커 스크립트의 지시에 따라 메모리 내 사용자 프로그램의 레이아웃을 설정
- **링커 스크립트**: 세그먼트의 이름과 위치를 링커에게 알려줌

## 사용자 메모리 접근

- 커널은 시스템 호출의 일부로서 사용자 프로그램이 제공한 포인터를 통해 메모리에 접근해야하는 경우가 맍음
- 사용자가 NULL 포인터, 매핑되지 않은 가상메모리를 가리키는 포인터, 커널 가장 주소공간을 가리지큰 포인터를 전달 할 수 있음
- 처리 방법 두 가지
    1. 유효성 검증 후, 역참조(derefernce)

    - `thread/mmu.c`, `include/threads/vaddr/h` 참조.
    - 가장 **간단한** 방법

    2. 사용자 포인터가 `KERN_BASE` 보다 아래를 가리키는지 확인한 다음 바로 역참조하는 것.

    - 유효하지 않은 사용자 포인터는 페이지 폴트를 유발하며, 이는 `userprog/exception.c`의 `page_fault()` 코드를 수정하여 처리
    - 프로세서의 MMU(메모리 관리 장치)를 활용 -> 일반적으로 빠르고 실제로 주로 사용됨
- [리소스 누수](#리소스-누수)가 발생하지 않도록 주의해야함.

### 2번 방법에 대한 유용한 코드

```c
/* 사용자 가상 주소 UADDR의 한 바이트를 읽습니다.
* UADDR은 KERN_BASE 미만이어야 합니다.
* 성공하면 바이트 값을 반환하고, 세그멘테이션 폴트가 발생하면 -1을 반환합니다. */
  static int64_t get_user (const uint8_t *uaddr) {
  int64_t result;
  __asm __volatile (
  "movabsq $done_get, %0\n" // done_get 레이블의 주소를 result에 저장
  "movzbq %1, %0\n"         // *uaddr에서 한 바이트를 읽어 0으로 확장하여 result에 저장
  "done_get:\n"             // done_get 레이블
  : "=&a" (result) : "m" (*uaddr)); // result는 %rax, *uaddr는 메모리 operand
  return result;
  }

/* 사용자 주소 UDST에 BYTE를 씁니다.

* UDST는 KERN_BASE 미만이어야 합니다.
* 성공하면 true를 반환하고, 세그멘테이션 폴트가 발생하면 false를 반환합니다. */
  static bool put_user (uint8_t *udst, uint8_t byte) {
  int64_t error_code;
  __asm __volatile (
  "movabsq $done_put, %0\n" // done_put 레이블의 주소를 error_code에 저장
  "movb %b2, %1\n"         // byte의 하위 8비트를 *udst에 쓴다
  "done_put:\n"            // done_put 레이블
  : "=&a" (error_code), "=m" (*udst) : "q" (byte)); // error_code는 %rax, *udst는 메모리 operand, byte는 레지스터/메모리 operand
  return error_code != -1;
  }
```

- 모두 사용자 주소가 이미 KERN_BASE 미만임을 검증했다고 가정한 함수들임.
- `page_fault()` 수정해, 커널에서 페이지 폴트가 발생하면 단순히 rax를 -1로 설정하고 이전 값을 %rip에 복사하도록 했다고 가정

---

# Argument Passing

- `process_exec()`에서 사용자 프로그램의 인자 설정하기

## x86-64 호출 규약 (Calling Convention)

1. 사용자 수준 애플리케이션은 인자 전달을 위해 정수 레지스터를 사용 -> `%rdi`, `%rsi`, `%rdx`, `%rcx`, `%r8`, `%r9` (순서 주의)
2. caller는 다음 명령어 주소를 스택에 푸시 -> 돌아오기 위해서
3. callee의 첫번째 명령어로 점프 -> 2번과 3번을 `CALL` 명령어로 수행
4. callee 실행 후 반환값이 있다면 `%rax` 레지스터에 저장
5. callee는 스택에서 반환주소를 pop 하고 `RET` 명령어를 통해 해당 주소로 점프

- ex) `f(1,2,3)`에 대해 4번 실행에서 callee가 보는 상채
    - `stack pointer -> 0x4747fe70: return address`
    - `RDI: 0x0000000000000001 | RSI: 0x0000000000000002 | RDX: 0x0000000000000003`

## 프로그램 시작 상세 정보

- `lib/user/entry.c`의 [`_start()`](#`start()`)가 사용자 프로그램의 **진입점**.
- 사용자 프로그램 실행 전, **초기 함수의 인자들을 레지스터에 넣어야함.**
- 명령어 인자 처리 방법 -> `/bin/ls -l foo bar`
    1. 명령어를 단어 단위로 분리: `/bin/ls`, `-l`, `foo`, `bar` -> 모두 `argv`의 요소들임
    2. 단어들을 스택 맨위에 배치 -> 순서 상관없음
    3. 2번의 주소(포인터)들을 다시 스택에 push해서 `argv` 배열 구성

    - 주의할 점
        - `argv[0] = /bin/ls`이 스택의 가장 낮은 주소여야하며 순서대로 올라가야함.
        - `argv[argc] == NULL`
        - 첫 푸시 전에 워드 정렬을 위해 8의 배수로 내림하여 정렬하기

    4. `%rsi` = `argv`의 주소 / `%rdi` = `argc`
    5. 스택에 가짜 "반환 주소"를 푸시 -> 다른 함수와 동일한 구조를 가지기 위해.

| Address    | Name           | Data        | Type        |
|------------|----------------|-------------|-------------|
| 0x4747fffc | argv[3][...]   | 'bar\0'     | char[4]     |
| 0x4747fff8 | argv[2][...]   | 'foo\0'     | char[4]     |
| 0x4747fff5 | argv[1][...]   | '-l\0'      | char[3]     |
| 0x4747ffed | argv[0][...]   | '/bin/ls\0' | char[8]     |
| 0x4747ffe8 | word-align     | 0           | uint8_t[]   |
| 0x4747ffe0 | argv[4]        | 0           | char *      |
| 0x4747ffd8 | argv[3]        | 0x4747fffc  | char *      |
| 0x4747ffd0 | argv[2]        | 0x4747fff8  | char *      |
| 0x4747ffc8 | argv[1]        | 0x4747fff5  | char *      |
| 0x4747ffc0 | argv[0]        | 0x4747ffed  | char *      |
| 0x4747ffb8 | return address | 0           | void (*) () |

> RDI: 4 | RSI: 0x4747ffc0

## 인자 전달 구현하기

- 현재 `process_exec()`: 인자 전달 지원 x
- f_name -> 공백을 통해 구분
    - 1: 프로그램 이름
    - 2: 첫 번째 인자
    - 3: 두 번째 인자
    - ...
- 명령줄 인자의 길이에 합리적인 제한을 둘 수 있음
    - 제한 하려면 4KB 정도로
    - 필수는 아니며, 이미 커널에 전달되는 명렬줄 자체의 길이가 128바이트로 제한됨.
- 참고
    - `include/lib/string.h`에 프로토 타입
    - `lib/string.c`에 `strtok_r()`

---

# System Calls

- `userprog/syscall.c`에서 **시스템 호출 핸들러** 구현
- Project1: OS가 사용자 프로그램으로부터 제어권을 되찾는 방법 중 타이머로부터의 인터럽트를 다룸 -> _외부 인터럽트_
- Project2: _프로그램 코드 내_에서 발생하는 소프트웨어 예외 처리구현 -> 페이지 폴트, 0으로 나누기 / 시스템 호출
- `syscall` 명령어: 시스템 호출을 호출하는 가장 일반적인 방법
    - `syscall_handler(struct intr_frame *)`: 시스템 호출 핸들러
    - `syscall_handler()`가 제어권을 얻었을 때, **호출자의 레지스터**에 저장된 정보
        - 시스템 호출 번호: `%rax`
        - 관련 인자: `%rdi`, `%rsi`, `%rdx`, **`%r10`**, `%r8`, `%r9` -> 순서 지켜야 함 / rcx만 r10으로 다름
    - `syscall_handler()`가 반환될 때 **호출자의 레지스터**에 저장돼야할 정보
        - 반환값: `%rax`
    - 호출자의 레지스터에 접근하는 방법: 인자로 넘겨받은 [`struct intr_frame`](#intr_frame)을 통해 접근 (커널 스택에 저장되어있음)

## 구현

- `include/lib/syscall-nr.h`: 각 시스템 호풀에 대한 호출 번호 정보 정의되어 있음
- 여러 사용자 프로세스가 동시에 시스템을 호출할 수 있도록 **동기화**해야함.
    - 특히 `filesys` 코드는 임계역역으로 처리해야햠 -> `process_exec()`도 파일에 접근함
- `lib/user/syscall.c`: 각 시스템 호출에 대한 사용자 수준의 함수가 제공. -> 사용자 프로세스가 C프로그램에서 각 시스템 콜을 호출하는 방법 제공
- 사용자 프로그램이 OS를 종료시킬 수 있는 유일한 방법은 `halt` 시스템 콜을 호출하는 것
- 유효하지 않은 인자가 전달
    - 허용되는 옵션은 오류 값 반환
    - or 정의되지 않은 값 반환
    - or 프로세스 종료입니다.

### `void halt (void);`

- **운영체제 전체 종료**
- `power_off()` (`src/include/threads/init.h`에 선언됨)를 호출하여 Pintos를 종료
- +) **시스템이 더 이상 진행될 수 없는 최후의 수단"**으로만 사용.
- +) 강제 종료하기 때문에 시스템의 현재 상태(레지스터 값, 메모리 내용, 로그 파일 등)를 정상적으로 저장하거나 정리할 시간을 주지 않음

### `void exit (int status);`

- **현재 사용자 프로그램을 종료**하고 **`status`를 커널에 반환**
- 해당 프로세스의 부모가 `wait`를 하는 경우 이 `status`가 반환됨
    - 0: 성공
    - 0 제외: 오류

### `pid_t fork (const char *thread_name);`

- 현재 프로세스의 **복제본인 새 프로세스**를 `thread_name`이라는 이름으로 **생성**
- 복제
    - 레지스터 값: `%RBX`, `%RSP`, `%RBP`, `%R12` ~ `%R15`와 같이 **피호출자 저장(callee-saved) 레지스터**만 복제
    - 파일 디스크립
    - 가상 메모리 공간
    - `threads/mmu.c`의 `pml4_for_each()`
        - 전체 사용자 메모리 공간을 복사
        - 단, 전달된 `pte_for_each_func`의 누락된 부분을 채워야함 -> [참고](#virtaul-address)
- 반환
    - 부모 프로세스(호출한 쪽): 자식 프로세스의 PID를 반환 / 실패하면 TID_ERROR 반환
    - 자식 프로세스(생성된 쪽): `0`

### `int exec (const char *cmd_line);`

- `cmd_line`에 주어진 이름을 가진 실행파일로 **현재 프로세스 변경**하고 **주어진 인자 전달**
- 반환
    - 성공: 반환 안 됨
    - 실패: 프로세스 종료 및 종료 상태 `-1` 반환
- 주의: exec 호출 시 파일 디스크립터는 열린 상태로 유지

### `int wait (pid_t pid);`

- 자식 프로세스 `pid`의 종료를 기다리고 자식의 종료 상태를 받음
- 진행 방식
    - (부모) `pid`가 아직 살아있다면, 종료될 때까지 기다림
    - (자식) 종료, `exit()`의 인자로 종료 상태 전달
    - (부모) `exit()`에 넘긴 종료상태를 부모에게 반환 -> 다른 방식으로 종료되었다면 `-1` 반환
- 즉시 실패 후 `-1` 반환
    - `pid`가 호출한 프로세스의 직계 자식이 아닌 경우
        - 상속관계가 A -> B -> C 인 경우, A->B와 B->C만 직계 관계임.
    - 동일한 `pid`에 대해 wait를 이미 호출한 경우 -> 중복 호출 불가
- 프로세스의 모든 리소스(`struct thread` 포함)는 어떤 경우에도 (부모가 기다리든 기다리지 않든, 그리고 자식이 부모보다 먼저 종료되든 나중에 종료되든) 해제되어야 함
- `process_wait()` (`userprog/process.c`)
    - 초기 프로세스가 종료될 때까지 Pintos가 종료되어선 안 되는데 `main()` (`threads/init.c`)에서 `process_wait()`를 호출해서 이를 시도함
    - **`process_wait()`를 사용하여 `wait` 시스템콜을 구현하는 것이 좋음**
- 난이도: 상

### `bool create (const char *file, unsigned initial_size);`

- file이라는 **새 파일**을 initial_size 바이트 크기로 **생성**
- 반환
    - 성공: `true`
    - 실패: `false`

### `bool remove (const char *file);`

- file이라는 **파일을 삭제**
- 반환
    - 성공: `true`
    - 실패: `false`
- 열린 파일을 제거해도 파일이 닫히는 것은 아님 -> FAQ의 [Removing an Open File](#Removing-an-Open-File)을 참조

### `int open (const char *file);`

- file이라는 **파일을 염**
- 반환
    - 성공: **"파일 디스크립터"**(fd)를 반환 -> 음수가 아닌 정수
        - fd = 0: 표준입력(`STDIN_FILENO`)
        - fd = 1: 표준출력(`STDOUT_FILENO`)
        - 위 둘은 절대로 반환하지 않음
    - 실패: -1
- 각 프로세스는 독립적인 파일 디스크립터 집합을 가짐
-

### `int filesize (int fd);`

- `fd`로 열린 **파일의 크기**를 **바이트 단위**로 반환

### `int read (int fd, void *buffer, unsigned size);`

- **`fd`로 열린 파일에서 `size` 바이트를 `buffer`로 읽어옴.**
- 반환
    - 읽을 수 있는 경우: 실제로 읽은 바이트 수
        - 파일 끝일 경우 0
    - 읽을 수 없는 경우(파일 끝 제외): -1
- `fd` = 0의 경우 `input_getc()`을 이용해 키보드에서 읽음

### `int write (int fd, const void *buffer, unsigned size);`

- **buffer에서 열린 파일 `fd`로 `size` 바이트를 씀**
- 반환
    - 쓸 수 있는 경우: 실제로 쓰여진 바이트 수
    - 써야하는 `buffer` 사이즈 보다 파일 사이즈가 작을 경우
        - 가능한 만큼 쓰고 실제 쓰여진 바이트수 반환
        - 아예 쓰여진 바이트가 없으면 0 반환
- `fd` = 1은 `putbuf()`를 이용해 콘솔에 씀
    - **한 번의 호출로 buffer의 모든 내용을 작성해야함**
        - 버퍼 size가 수백 바이트보다 크지 않는 한
        - 더 큰 버퍼는 분할해야.

### `void seek (int fd, unsigned position);`

- 열린 파일 `fd`에서 **읽거나 쓸 다음 바이트를 `position` 바이트로 변경**
- 파일의 현재 끝을 넘어서 seek하는 것
    - 오류 X
    - 이후의 `read`는 0 바이트를 얻어 파일 끝을 나타냄
    - 이후의 `write`는 Pintos에서는 오류를 반환 -> (원래 파일을 확장하고, 쓰여지지 않은 간격을 0으로 채움)

### `unsigned tell (int fd);`

- 열린 파일 `fd`에서 **읽거나 쓸 다음 바이트의 위치**를 파일 시작으로부터 바이트 단위로 **반환**

### `void close (int fd);`

- **파일 디스크립터 fd를 닫음**
- 프로세스를 종료나 중단시, 각 파일 디스크립터에 대해 이 함수를 호출하는 것처럼, 열려 있는 모든 파일 디스크립터가 암시적으로 닫힘 -> 그렇게 구현해줘야 한다는 뜻 같음

---

# 추가 정보

## 세그먼트 아키텍처

- 메모리를 여러 개의 논리적인 섹션, 즉 세그먼트(segments)로 나누어 관리하는 방식
- 각 세그먼트는 특정 유형의 정보를 담도록 설계되며, 예를 들어 코드 세그먼트, 데이터 세그먼트, 스택 세그먼트 등으로 나눌 수 있음
- 메모리에 접근할 때:  **세그먼트 레지스터(segment register)**와 **오프셋(offset)**의 조합을 사용
    - 세그먼트 레지스터: 현재 접근하려는 메모리가 어떤 세그먼트에 속하는지를 가리키는 역할. 고유한 시작 주소와 크기가 있음
    - 오프셋: 세그먼트의 시작 주소로부터 실제 데이터가 있는 위치까지의 상대적인 거리

## 열린 파일 제거

- https://casys-kaist.github.io/pintos-kaist/project2/FAQ.html

## 리소스 누수

- 프로그램이 할당받은 컴퓨터 자원(resource)을 사용한 뒤 제대로 해제하지 않아서, 그 자원이 계속해서 시스템에 묶여 다른 프로그램이나 시스템 자체가 사용할 수 없게 되는 현상
- 메모리:  malloc 같은 함수를 통해 메모리를 할당받은 후, free를 호출하여 해제하지 않는 경우
- 파일 핸들: 파일을 열어서 작업한 후 close 함수로 닫지 않는 경우
- 락/뮤텍스: 락 획득 후 락을 해제하지 못한 경우
- 스레드/프로세스: 자식 스레드나 프로세스를 생성 후 제대로 종료시키거나 자원을 회수 하지 않는 경우.

## `_start()`

- Pintos 사용자 프로그램의 실제 시작 지점
- `main()` 함수 호출
    - 커널은 `argc`와 `argv` 값을 미리 준비해서 `_start()` 함수에 전달
    - `_start()`는 그걸 `main(argc, argv)`로 넘겨줌
- `exit()` 호출
    - `main(argc, argv)`의 반환 값(종료 상태)을 `exit()` 함수의 인자로 전달
        - `0`: 정상 종료
        - 이외: 오류
    - `exit()`는
        - 시스템 호출(system call)을 통해 커널에 종료 상태를 전달
        - 프로그램이 사용하던 모든 시스템 자원(열린 파일, 할당된 메모리 등)을 정리하고 해제하는 데 도움을 줌

## `intr_frame`

- 인터럽트나 시스템 호출이 발생했을 때 CPU가 자동으로 저장하는 스냅샷
- 이 스냅샷은 해당 스레드의 커널 스택 영역에 위치

## virtaul address

- https://casys-kaist.github.io/pintos-kaist/appendix/virtual_address.html

## Removing an Open File

열려 있는 파일이 삭제될 때 표준 유닉스(Unix) 방식을 구현해야 합니다. 즉, 파일이 제거되어도 해당 파일의 파일 디스크립터를 가진 모든 프로세스는 그 디스크립터를 계속 사용할 수 있습니다. 이는 해당 파일로부터
읽고 쓰는 것이 가능하다는 의미입니다. 파일은 이름을 잃고, 다른 프로세스는 파일을 열 수 없게 되지만, 해당 파일을 참조하는 모든 파일 디스크립터가 닫히거나 시스템이 종료될 때까지 계속 존재합니다.